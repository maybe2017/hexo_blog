---
title: MySQL索引背后的数据结构
date: 2023-07-26 11:30:25
comments: true
layout: post
toc: true
tags:
  - 数据库/MySQL
categories: 存储
---

### 一、前言

本次以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。需要说明的是，MySQL 支持诸多存储引擎，而各种存储引擎对索引的支持也不尽相同，因此 MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等。<span style="color:red;">本此只关注于 BTree 索引，因为这是我们平常使用 MySQL 时主要用到的索引。</span>

### 二、索引的本质

索引的定义：<span style="color:orange;">索引（Index）是</span>帮助 MySQL 高效获取数据的<span style="color:orange;">数据结构</span>。

通常场景，查询是数据库的最主要功能之一，都希望查询数据的速度能尽可能的快，那么如何让它快呢？

| 算法            | 时间复杂度 | 说明                                                                                                                            |
| :-------------- | :--------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 顺序查找        | O(n)       | 6                                                                                                                               |
| 二分查找        | O(logn)    | 用得极多                                                                                                                        |
| 二叉查找树(BST) | O(logn)    | 无法保证平衡，可能退化为链表；                                                                                                  |
| 平衡二叉树(AVL) | O(logn)    | 通过旋转解决了平衡的问题，但是旋转操作效率太低                                                                                  |
| 红黑树          | O(h)       | 通过舍弃严格的平衡和引入红黑节点，解决了 AVL 旋转效率过低的问题，但是在磁盘等场景下，树仍然太高                                 |
| B 树            |            | 通过将二叉树改为多路平衡查找树，解决了树过高的问题                                                                              |
| B+树            | O(logn)    | 在 B 树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效 |

每种查找算法都只能应用于特定的数据结构，二分查找需要被检索数据有序，二叉树查找必须应用于二叉查找树上，但是真实数据本身的组织结构不可能完全满足同一数据结构（不可能一条数据的两列字段同时都按同一顺序组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

![图一.png](https://note.youdao.com/yws/res/101/WEBRESOURCE2cbbab2bffe11e9418b224ada9bed7dd)

为了加快列 2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在 O(log2n)O(log2n)的复杂度内获取到相应数据。

实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树实现的（太高啦）。

### 三、磁盘存取原理

[磁盘基础](https://www.cnblogs.com/jswang/p/9071847.html)

![磁盘与innodb.png](https://note.youdao.com/yws/res/110/WEBRESOURCE7caccc102c89e41b9afaf1c177e68422)

索引一般以文件形式存储在磁盘上，索引检索需要磁盘 I/O 操作。与主存不同，磁盘 I/O 存在机械运动耗费，因此磁盘 I/O 的时间消耗是巨大的。

一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。

盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。

当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。

### 四、局部性原理与磁盘预读

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：

当一个数据被用到时，其附近的数据也通常会马上被使用。

程序运行期间所需要的数据通常比较集中。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。

预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

操作系统都有预读的机制，即使你只查询一条数据，但是操作系统最开始会读取 4 个连续 page 的数据（这里的 page 一般是 4K-16K 不等，而一个磁盘扇区大小是 512B），一旦在 PageCache 中命中，下次会读取 8 个 page 的数据，如果再次命中，第三次读取 16 个 page 的数据，不过最后每次最多预读 32 个 page 的数据（32 页封顶）。这个理论详见于 linux 内核 3.10。

## 五、B- Tree 和 B+ Tree

[索引基础](https://blog.csdn.net/mingyuli/article/details/120791657)

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

先看看为什么会出现 B-树这类数据结构？

传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就够呛了。当数据量非常大时，内存不够用，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。一般而言内存访问的时间约为 50 ns，而磁盘在 10 ms 左右。速度相差了近 5 个数量级，磁盘读取时间远远超过了数据在内存中比较的时间，即程序大部分时间会阻塞在磁盘 IO 上。

那么我们如何提高程序性能？
减少磁盘 IO 次数，像 AVL 树，红黑树这类平衡二叉树从设计上无法适配磁盘。

### 六、数据结构

1.  先建一个表:
    **`CREATE TABLE index_demo(c1 INT,c2 INT,c3 CHAR(1),PRIMARY KEY(c1)) ROW_FORMAT = Compact;`**

        简化后的 index_demo 表的行格式示意图：

![行格式说明.png](https://note.youdao.com/yws/res/214/WEBRESOURCE8f37bc9f24e5866aa2ea2eec08d98281)

2.假设每个数据页最多能存放 3 条记录（实际上一个数据页非常大，可以存放下好多记录）。然后我们向 index_demo 表插入 3 条记录：
**`INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');`**

![第一次插入.png](https://note.youdao.com/yws/res/233/WEBRESOURCE7febef13562576f30d4308d851b20f16)

3.记录已经按照主键值的大小串联成一个单向链表，此时我们再来插入一条记录:
**`INSERT INTO index_demo VALUES(4, 4, 'a');`**

![页分裂1.png](https://note.youdao.com/yws/res/241/WEBRESOURCE31b45323926fecaba5b52e09f120e0b8)

注意:

- 数据页编号可能并不是连续的, 只是维护着链表关系；
- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。

![页分裂2.png](https://note.youdao.com/yws/res/252/WEBRESOURCE4c92cd80fb3cf208853f13142f56ecd8)

由于数据页的编号可能并不是连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：

![数据页不连续.png](https://note.youdao.com/yws/res/255/WEBRESOURCE305282dfd16356dbcf54cdaea658cedb)

因为这些 16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，就需要给它们做个目录，每个页对应一个目录项，每个目录项包括:

- 页的用户记录中最小的主键值,
- 页号

<span style="color:orange;">这个目录就是索引。</span>

![目录数据页.png](https://note.youdao.com/yws/res/269/WEBRESOURCEaf5a6d77b47b9877dd589250361c0b2c)

那么根据某个主键值去查找记录的步骤就可以大致拆分成下边两步，比如查找逐渐为 20 的记录:

- 先到存储目录项记录的页，也就是页 30 中通过二分法定位到对应目录项，因为 12 < 20 < 209 ，所以定位到对应的记录所在的页为页 9。
- 再到存储用户记录的页 9 中，根据二分法快速定位到主键值为 20 的记录。

  4.目录项记录中只存储主键值和对应的页号,因此与存储真实记录的数据页相比，每个页存储的条数要远远大于后者，假设一个存储目录项记录的页最多只能存放 4 条目录项记录，所以如果此时再向上图中插入一条主键值为 320 的记录的话，那就需要分配一个新的存储目录项记录的页：

![目录页增加1.png](https://note.youdao.com/yws/res/286/WEBRESOURCE02c630a18095de50c1597b8547e4d35b)

5.如果我们表中的数据非常多则会产生很多存储目录项记录的页，那如何根据主键值快速定位一个存储目录项记录的页呢？也简单，为这些存储目录项记录的页再生成一个更高级的目录，如下图:

![目录页增加2.png](https://note.youdao.com/yws/res/293/WEBRESOURCEa7dd9ad5e62f89b11755f7491f6360f8)

假设所有存放记录的叶子节点代表的数据页可以存放 100 条用户记录，所有存放目录项记录的内节点代表的数据页可以存放 1000 条目录项记录，那么：

- 如果 B+ 树只有 1 层，也就是只有 1 个用于存放用户记录的节点，最多能存放 100 条记录。
- 如果 B+ 树有 2 层，最多能存放 1000×100=100000 条记录。
- 如果 B+ 树有 3 层，最多能存放 1000×1000×100=100000000 条记录。
- 如果 B+ 树有 4 层，最多能存放 1000×1000×1000×100=100000000000 条记录。
- 16384 / 一条记录占字节数 = 存放记录数

所以一般情况下，我们用到的 B+树都不会超过 4 层，通过主键值去查找某条记录最多只需要做 4 个页面内的查找（查找 3 个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录！

6.聚簇索引，上文描述的结构就是聚簇索引，其特点为:

- 使用记录主键值的大小进行记录和页的排序;
- B+ 树的叶子节点存储的是完整的用户记录。

==这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建，InnoDB 存储引擎会自动的为我们创建聚簇索引。==

7.二级索引（辅助索引），比如用 C2 列建立索引

- 使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2 列+主键这两个列的值。
- 目录项记录中不再是主键+页号的搭配，而变成了 c2 列+页号的搭配。

  8.联合索引，即同时以多个列的大小作为排序规则，比如建立 C2、C3 列联合索引

- 先把各个记录和页按照 c2 列进行排序；
- 在记录的 c2 列相同的情况下，采用 c3 列进行排序
- 每条目录项记录都由 c2 、c3 、页号这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序
- B+ 树叶子节点处的用户记录由 c2 、c3 和主键 c1 列组成。

![联合索引.png](https://note.youdao.com/yws/res/339/WEBRESOURCEf5809de0d109ba6f4ff56e4c716bbe88)

为什么数据库中索引的数据结构用 B+树而非 B 树？

1. 因为其非叶子节点不存储数据；
2. 第二点是可以进行区间查询；
3. 第三点查询时间复杂度固定。

## 七、空间换时间

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度，即索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

InnoDB 的数据文件本身就是索引文件。在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。
